#include "mlir/Pass/Pass.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/IR/Builders.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"

// These are the headers that would be generated by tblgen
#include "SimulatorOps.h.inc"

namespace {

// A helper to create an LLVM function declaration
static mlir::LLVM::LLVMFuncOp getOrInsertQirFunc(mlir::PatternRewriter &rewriter, mlir::ModuleOp module,
                                               std::string funcName, mlir::Type qubit_ptr_type) {
    auto func = module.lookupSymbol<mlir::LLVM::LLVMFuncOp>(funcName);
    if (!func) {
        auto func_type = mlir::LLVM::LLVMFunctionType::get(mlir::LLVM::LLVMVoidType::get(rewriter.getContext()), {qubit_ptr_type});
        rewriter.setInsertionPointToStart(module.getBody());
        func = rewriter.create<mlir::LLVM::LLVMFuncOp>(rewriter.getUnknownLoc(), funcName, func_type);
    }
    return func;
}

// Lowering pattern for sim.apply_gate
struct ApplyGateToQirLowering : public mlir::OpRewritePattern<rocq::mlir::sim::ApplyGateOp> {
    using OpRewritePattern<rocq::mlir::sim::ApplyGateOp>::OpRewritePattern;

    mlir::LogicalResult matchAndRewrite(rocq::mlir::sim::ApplyGateOp op, mlir::PatternRewriter &rewriter) const override {
        auto module = op->getParentOfType<mlir::ModuleOp>();
        std::string gate_name = op.getGateName().str();
        
        // QIR function names are mangled
        std::string qir_func_name = "__quantum__qis__" + gate_name + "__body";

        // In QIR, qubits are represented as opaque pointers: !llvm.ptr<struct<"Qubit", opaque>>
        auto qubit_type = mlir::LLVM::LLVMPointerType::get(rewriter.getContext());

        auto qir_func = getOrInsertQirFunc(rewriter, module, qir_func_name, qubit_type);
        
        rewriter.create<mlir::LLVM::CallOp>(op.getLoc(), qir_func, op.getTargets());
        rewriter.eraseOp(op);
        return mlir::LogicalResult::success();
    }
};

// The main pass definition
struct SimulatorToQIRPass : public mlir::PassWrapper<SimulatorToQIRPass, mlir::OperationPass<mlir::ModuleOp>> {
    MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimulatorToQIRPass)

    void getDependentDialects(mlir::DialectRegistry &registry) const override {
        registry.insert<mlir::LLVM::LLVMDialect>();
    }

    void runOnOperation() override {
        mlir::ConversionTarget target(getContext());
        target.addLegalDialect<mlir::LLVM::LLVMDialect>();
        target.addIllegalDialect<rocq::mlir::sim::SimulatorDialect>();
        target.addLegalOp<mlir::ModuleOp>(); // ModuleOp is always legal

        mlir::RewritePatternSet patterns(&getContext());
        patterns.add<ApplyGateToQirLowering>(&getContext());

        if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
            signalPassFailure();
        }
    }
};

} // anonymous namespace

// Factory function to create a new pass instance
std::unique_ptr<mlir::Pass> createSimulatorToQIRPass() {
    return std::make_unique<SimulatorToQIRPass>();
}
