#include "mlir/Pass/Pass.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/IR/Builders.h"

// These are the headers that would be generated by tblgen
#include "QuantumOps.h.inc"
#include "SimulatorOps.h.inc"

namespace {

// Generic lowering pattern for simple, non-parametrized gates
template <typename SourceOp>
struct GateLoweringPattern : public mlir::OpRewritePattern<SourceOp> {
    using mlir::OpRewritePattern<SourceOp>::OpRewritePattern;
    
    GateLoweringPattern(mlir::MLIRContext *context, std::string gate_name)
        : mlir::OpRewritePattern<SourceOp>(context), gate_name(std::move(gate_name)) {}

    mlir::LogicalResult matchAndRewrite(SourceOp op, mlir::PatternRewriter &rewriter) const override {
        rewriter.replaceOpWithNewOp<rocq::mlir::sim::ApplyGateOp>(
            op, rewriter.getStringAttr(gate_name), op->getOperands());
        return mlir::LogicalResult::success();
    }
private:
    std::string gate_name;
};

// The main pass definition
struct QuantumToSimulatorPass : public mlir::PassWrapper<QuantumToSimulatorPass, mlir::OperationPass<mlir::ModuleOp>> {
    MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumToSimulatorPass)

    void getDependentDialects(mlir::DialectRegistry &registry) const override {
        registry.insert<rocq::mlir::quantum::QuantumDialect, rocq::mlir::sim::SimulatorDialect>();
    }

    void runOnOperation() override {
        mlir::ConversionTarget target(getContext());
        target.addLegalDialect<mlir::func::FuncDialect, rocq::mlir::sim::SimulatorDialect>();
        target.addIllegalDialect<rocq::mlir::quantum::QuantumDialect>();

        mlir::RewritePatternSet patterns(&getContext());
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::HOp>>(&getContext(), "h");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::XOp>>(&getContext(), "x");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::YOp>>(&getContext(), "y");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::CnotOp>>(&getContext(), "cnot");
        // Add other gate lowerings here...

        if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
            signalPassFailure();
        }
    }
};

} // anonymous namespace

// Factory function to create a new pass instance
std::unique_ptr<mlir::Pass> createQuantumToSimulatorPass() {
    return std::make_unique<QuantumToSimulatorPass>();
}