#include "rocquantum/Dialect/QuantumDialect.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/DialectImplementation.h"
#include "llvm/ADT/TypeSwitch.h" // For parsing/printing custom types

// Placeholders for Op definitions if not using TableGen fully yet
// These would normally come from an ODS file.
// For C++ defined Ops, they need to inherit from mlir::Op<>

namespace rocquantum {
namespace quantum {

// --- QubitType Methods ---
// (Normally in a separate Types.cpp or generated)
namespace detail {
// Define storage for QubitType. For simple types without parameters, it can be empty.
struct QubitTypeStorage : public mlir::TypeStorage {
    using KeyTy = void; // No parameters for this simple type
    bool operator==(const KeyTy &) const { return true; }
    static llvm::hash_code hashKey(const KeyTy &) { return llvm::hash_code(0); } // Dummy hash
    static KeyTy getKey() { return {}; } // Dummy key
    static mlir::TypeStorage *construct(mlir::TypeStorageAllocator &allocator, KeyTy) {
        return new (allocator.allocate<QubitTypeStorage>()) QubitTypeStorage();
    }
};
} // namespace detail

QubitType QubitType::get(mlir::MLIRContext *context) {
    return Base::get(context);
}

// --- QuantumDialect Methods ---

QuantumDialect::QuantumDialect(mlir::MLIRContext *ctx)
    : mlir::Dialect(getDialectNamespace(), ctx, mlir::TypeID::get<QuantumDialect>()) {
    // Register custom types here
    registerTypes();

    // Add operations to the dialect.
    // If using C++ Op definitions directly (not TableGen for everything):
    // addOperations<
    //     AllocQubitOp,
    //     DeallocQubitOp,
    //     GenericGateOp,
    //     MeasureOp
    // >();
    // For now, we'll assume ops will be added via initialize() using addOperations()
    // or that the GET_OP_CLASSES macro in the header will eventually define them.
    // The initialize() method is preferred for this.
}

void QuantumDialect::initialize() {
    // This is where operations would typically be added if generated by TableGen
    // For manually defined C++ ops, they might also be added here.
    // The include for QuantumOps.h.inc suggests TableGen is the ultimate goal.
    addOperations<
#define GET_OP_LIST
#include "rocquantum/Dialect/QuantumOps.cpp.inc" // Generated by TableGen
    >();
    // For now, since QuantumOps.cpp.inc doesn't exist, this will be empty or cause a build error.
    // We'll manually add placeholders if needed for this conceptual step.
    // If not using TableGen, you would list your C++ Op classes here:
    // addOperations<AllocQubitOp, DeallocQubitOp, GenericGateOp, MeasureOp>();
}


// Method to parse a custom type from its textual representation
mlir::Type QuantumDialect::parseType(mlir::DialectAsmParser &parser) const {
    llvm::StringRef keyword;
    if (parser.parseKeyword(&keyword)) return nullptr;

    if (keyword == QubitType::name) { // "quantum.qubit"
        return QubitType::get(getContext());
    }
    // Add other types here if any

    parser.emitError(parser.getNameLoc(), "unknown rocquantum.quantum type: ") << keyword;
    return nullptr;
}

// Method to print a custom type to its textual representation
void QuantumDialect::printType(mlir::Type type, mlir::DialectAsmPrinter &printer) const {
    if (type.isa<QubitType>()) {
        printer << QubitType::name;
        return;
    }
    // Add other types here
    llvm_unreachable("Unhandled rocquantum.quantum type");
}

void QuantumDialect::registerTypes() {
    addTypes<QubitType>();
}


// --- Manual C++ Op Definitions (Placeholders if not using TableGen yet) ---
// These are very simplified. Real MLIR ops require more boilerplate for builders,
// verifiers, parsers, printers, interfaces, etc.

// This is where the definitions for AllocQubitOp, DeallocQubitOp, GenericGateOp, MeasureOp
// would go if they were manually written in C++ instead of via TableGen.
// Example for one Op (very basic):
/*
namespace detail {
// For Ops without attributes or custom assembly format, these can be minimal
void AllocQubitOp::build(mlir::OpBuilder &builder, mlir::OperationState &state) {
    state.addTypes(QubitType::get(builder.getContext()));
}
// Add verifiers, printers, parsers as needed.
} // namespace detail
*/

// Note: The actual Op class definitions (like AllocQubitOp) are expected to be
// in QuantumOps.h.inc (generated by TableGen) or in separate .h/.cpp files for Ops.
// For this conceptual step, we assume these files will be created or generated.
// The #include "rocquantum/Dialect/QuantumOps.h.inc" in QuantumDialect.h and
// #include "rocquantum/Dialect/QuantumOps.cpp.inc" here are key for that.

} // namespace quantum
} // namespace rocquantum
