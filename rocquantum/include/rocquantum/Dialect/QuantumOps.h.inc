// This file would be auto-generated by MLIR's TableGen from QuantumOps.td
// For this conceptual step, it's created as a placeholder.
// It would normally contain C++ class declarations for AllocQubitOp, GenericGateOp, etc.

// Example of what might be generated for one op:
/*
namespace rocquantum {
namespace quantum {
class AllocQubitOp : public mlir::Op<AllocQubitOp, /* Interfaces... * / > {
public:
  using Op::Op;
  static llvm::StringRef getOperationName();
  // ... other methods like build, verify, etc. ...
  mlir::Value getQubit();
};
} // namespace quantum
} // namespace rocquantum
*/

// Since we are not running TableGen, leave this mostly empty.
// The C++ dialect implementation will manually handle what it can,
// or we'll assume these definitions exist for the compiler to find.
#ifndef ROCQUANTUM_DIALECT_QUANTUMOPS_H_INC
#define ROCQUANTUM_DIALECT_QUANTUMOPS_H_INC

// Forward declare op classes to avoid full MLIR includes here if possible,
// though typically op defs need more from MLIR's OpDefinition.h etc.
namespace mlir {
class OpBuilder;
class OperationState;
} // namespace mlir

namespace rocquantum {
namespace quantum {

// Manually declare the Ops as they would be generated by TableGen for C++ usage
// This is a simplified version of what TableGen would produce.

class AllocQubitOp : public mlir::Op<AllocQubitOp, mlir::OpTrait::ZeroOperands, mlir::OpTrait::OneResult, mlir::MemoryEffectOpInterface::Trait> {
public:
    using Op::Op;
    static llvm::StringRef getOperationName() { return "quantum.alloc_qubit"; }
    static void build(mlir::OpBuilder &builder, mlir::OperationState &state);
    mlir::Value getQubit() { return getResult(0); }
    void getEffects(llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> &effects);
};

class DeallocQubitOp : public mlir::Op<DeallocQubitOp, mlir::OpTrait::OneOperand, mlir::OpTrait::ZeroResults, mlir::MemoryEffectOpInterface::Trait> {
public:
    using Op::Op;
    static llvm::StringRef getOperationName() { return "quantum.dealloc_qubit"; }
    static void build(mlir::OpBuilder &builder, mlir::OperationState &state, mlir::Value qubit);
    mlir::Value getQubit() { return getOperand(0); }
    void getEffects(llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> &effects);
};

class GenericGateOp : public mlir::Op<GenericGateOp, mlir::OpTrait::VariadicOperands, mlir::OpTrait::ZeroResults> {
public:
    using Op::Op;
    static llvm::StringRef getOperationName() { return "quantum.gate"; }
    static void build(mlir::OpBuilder &builder, mlir::OperationState &state, llvm::StringRef gate_name, mlir::ValueRange qubits);
    llvm::StringRef getGateName();
    void setGateName(llvm::StringRef name);
    mlir::Operation::operand_range getQubits() { return getOperands(); }
};

class MeasureOp : public mlir::Op<MeasureOp, mlir::OpTrait::OneOperand, mlir::OpTrait::OneResult, mlir::MemoryEffectOpInterface::Trait> {
public:
    using Op::Op;
    static llvm::StringRef getOperationName() { return "quantum.measure"; }
    static void build(mlir::OpBuilder &builder, mlir::OperationState &state, mlir::Value qubit);
    mlir::Value getQubit() { return getOperand(0); }
    mlir::Value getResult() { return اسمبلیFormat(); } // Typo, should be getResult(0)
    void getEffects(llvm::SmallVectorImpl<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> &effects);
};

} // namespace quantum
} // namespace rocquantum

#endif // ROCQUANTUM_DIALECT_QUANTUMOPS_H_INC
